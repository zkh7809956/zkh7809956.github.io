{"meta":{"title":"赵牧一的象牙塔","subtitle":"华华有颗坚强的心--王者五集团上海地区总代理","description":"华华有颗坚强的心--王者五集团上海地区总代理","author":"赵坤鸿","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"模块化","slug":"模块化","date":"2017-08-18T12:22:30.000Z","updated":"2017-08-18T04:55:29.092Z","comments":true,"path":"2017/08/18/模块化/","link":"","permalink":"http://yoursite.com/2017/08/18/模块化/","excerpt":"","text":"#模块化 模块就是实现一个特定功能的一组代码，通常一个文件就是一个模块，我们前端模块化中，一个模块指的就是一个js文件。 模块化是把一个复杂的应用分解为很多的可管理的模块。 为什么要有模块化模块化最早出现在服务端语言中，因为服务端的逻辑通常都非常的复杂，如果不使用模块进行管理，那么系统会变得难以维护。 现在的网站越来越复杂，功能越来越强大，嵌入网页的Javascript代码越来越庞大，越来越复杂。 前端模块化编程，已经成为一个迫切的需求。理想情况下，不同的开发者只需要实现不同核心的业务逻辑，其他都可以加载别人已经写好的模块。 因此最简单的模块化做法就是：把一个独立的功能的所有js代码放到一个单独的JS文件中，这就算是一个模块了。使用的时候只需要引入这个js文件即可。 容易造成全局变量污染 模块之间的依赖关系必须靠程序员自己维护。 模块化的使用场景：在复杂的项目，越适合，如果是非常简单的项目，可以不使用模块化 模块化的标准有了模块，我们就可以更方便地使用别人的代码,想要什么功能，就加载什么模块。这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！ 【螺丝与螺帽】 CommonJS：是一个模块化的标准，Node.js在使用的模块化标准。适用与后端开发的标准。 AMD（Async Module Definition）：在CommonJS基础上衍生出来的适用于前端开发的模块化标准。 特点：预加载，第一次访问时，将所有的文件都加载出来。 优点：第一次访问完成以后，再次访问速度会很快 缺点：第一次加载，需要的时间会比较长 代表：requirejs CMD（Common Module Definition）：在CommonJS基础上衍生出来的适用于前端开发的模块化标准。 特点：懒加载，只有使用到的时候，才会加载对应的模块。 优点：第一次访问速度会比较快 缺点：再次访问其他模块时会比较慢。 代表：seajs require.JSrequire.js概念requirejs是AMD规范的一个实现，require.js是一个javascript文件，也是一个模块加载器。模块加载器：相当于canvas中封装的图片加载器，只不过一个是加载图片的，一个加载js，文件的类型不一样。 官网地址 github地址 requirejs主要提供两大功能： 加载模块：可以加载AMD规范的模块，也可以是普通的模块，异步加载，并且能够管理模块之间的依赖。 规范了模块的定义：有助于不同模块之间的共享与依赖。 requirejs的优点： 提高了javascript文件的加载速度，避免不必要的堵塞。 独特的模块定义方式可以避免全局变量污染。 独特的模块定义方式可以在脚本层面声明模块之间的依赖。 requirejs初体验一、引入js文件 &lt;!--1. 引入require.js文件--&gt;&lt;script src=\"require.js\"&gt;&lt;/script&gt; 二、定义模块 //在a.js文件中console.log(\"a模块加载了\"); 三、引用模块 //require会自动找当前目录下的js文件，a是文件名，不能写后缀。require([\"a\"]); API详解requirejs一共对外暴露三个全局变量 requirejs - 用于加载模块 require - 用于加载模块 define - 用于定义模块 require和requirejs是同一个函数，类似于$和jQuery的关系 require加载模块 作用：加载模块（amd模块或者是普通模块） 加载普通模块，模块加载完是会执行一遍的。 //第一个参数：数组，需要加载的模块，异步加载的//第二个参数：回调函数，在模块都加载完毕之后，回调函数才会执行//require([\"js/a\", \"js/b\", \"js/c\"]);require([\"js/a\", \"js/b\", \"js/c\"],function () &#123; console.log(\"我是最后执行的\");&#125;); define定义模块使用define函数可以定义一个AMD规范的模块 //第一个参数：模块的依赖//第二个参数：模块的主体define([], function () &#123; console.log(\"a模块加载了\");&#125;); 好处：require独特的定义方式，避免了全局变量的污染。 模块之间的依赖在使用define定义一个模块时，如果模块依赖于另一个模块，我们可以通过define的第一个参数去指定。 //第一个参数：本模块依赖的模块列表 路径是以html的路径为基准//第二个参数：模块的主体define([\"js/a\"], function () &#123; console.log(\"a模块依赖与b模块\");&#125;); 优点：可以在声明模块的时候就可以定义好依赖，那么使用的时候，就不用在管模块之间的依赖了。使用起来会更加的方便。 模块的输出（对外暴露的东西）如果模块仅仅是执行一些代码实现某个功能，那么直接引入该模块，实现对应的功能即可，不需要返回值。如果该模块的存在是为了提供一些方法、对象或者其他一些内容，那么这个模块需要返回值。 在定义模块的时候，我们通常需要对外返回一些内容，因为使用define定义模块，实质就是一个函数，因此可以使用return返回模块的输出。 define([], function () &#123; var util = &#123; sayHello:function (name) &#123; console.log(\"大家好，我是\"+name); &#125;, sleep:function () &#123; console.log(\"好困啊，我想要睡觉\"); &#125; &#125;; //通过return返回模块的输出 return util;&#125;); 想要获取模块的输出，在function中传递形参即可。 //参数1：加载的模块列表//参数2：模块加载完成后，会执行的回调函数,形参就是模块的返回值require([\"b\"], function (util) &#123; util.sayHello(\"张三\"); util.sleep();&#125;); 如果依赖于多个模块，应该怎么办？ //1. 如果依赖于多个模块，并且多个模块都有输出，那么我们需要使用参数一一对应，//2. 这样就可以获取到多个模块的输出了。//3. 即便某个模块没有输出，我们也要指定一个参数占着位置。//4. 通常我们会把有输出的模块写在前面，没有输出的模块写在后面。这样方便写参数。require([\"js/util\", \"js/common\", \"js/test\"], function (util, demo) &#123; console.log(util); console.log(demo);&#125;); 配置路径和别名 使用require来加载某个模块时，路径会以当前html文件作为参考。 require可以使用config来配置一些内容，比如基础路径 require.config(&#123; //1. 配置所有模块的基础路径，该路径相对于引入了requirejs的html文件的路径。 //2. 所有的路径都会自动的拼上baseUrl baseUrl:\"js/\", //1. 给模块起别名，方便使用，在依赖的模块中也能使用 paths:&#123; \"common\":\"common/common\", \"util\":\"util/util\", \"test\":\"login/test\" &#125;&#125;);//引入模块时，只需要直接引入模块的别名即可。require([\"common\", \"util\", \"test\"],function (demo, util) &#123; console.log(demo); console.log(util);&#125;); 加载非AMD规范的模块requirejs可以通过require函数加载模块。在加载不是AMD规范的模式时，会出现问题，需要做特殊的处理。 市面上有很多模块，并没有实现AMD模块化规范，没有实现模块化的模块也可以使用requirejs去加载，但是require加载时，仅仅会执行这个js文件，并不能帮助这个模块实现依赖的加载，也无法获取到这个模块的输出。 我们可以通过require.config为没实现AMD规范加载依赖项。 require.config(&#123; baseUrl:\"js/\", path:&#123; \"base\":\"base\" &#125;, //垫：配置普通模块的依赖与输出 shim:&#123; \"base\":&#123; //配置普通模块的依赖项 deps:[\"依赖项1\",\"依赖项2\"], //配置模块的输出 exports: \"输出结果\" &#125; &#125;&#125;); 使用模块化加载jquery想使用模块化加载第三方库的时候，首先需要检查第第三方库是否支持模块化。 如上图，说明这个第三方库是支持模块化的，可以直接使用require进行加载。 具名模块与匿名模块 define声明时，第一个参数可以是该模块的名字，如果声明了模块名，在配置时，模块别名就不能够调整了。 requireJS的匿名模块和命名模块的差别和最佳实践 【练习：使用jquery与jquery.color插件实现颜色的渐变效果】 博学谷环境搭建设置虚拟主机 在C盘的www目录，新建了一个boxuegu文件夹 D:\\phpStudy\\Apache\\conf\\extra目录下找到httpd-vhosts.conf,打开编辑 &lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host.example.com #根目录 DocumentRoot \"C:\\www\\boxuegu\" #域名 ServerName boxuegu.com #完整域名 ServerAlias www.boxuegu.com ErrorLog \"logs/dummy-host.example.com-error.log\" CustomLog \"logs/dummy-host.example.com-access.log\" common&lt;/VirtualHost&gt; 修改host文件，C:\\Windows\\System32\\drivers\\etc找到hosts文件,添加以下内容 127.0.0.1 boxuegu.com127.0.0.1 www.boxuegu.com 注意：如果提示没有权限保存，先把hosts文件复制到桌面上，进行修改，修改完成之后，再拖回去，覆盖即可。 重启服务器，进行测试","categories":[{"name":"AMD","slug":"AMD","permalink":"http://yoursite.com/categories/AMD/"}],"tags":[{"name":"amd","slug":"amd","permalink":"http://yoursite.com/tags/amd/"},{"name":"requireJs","slug":"requireJs","permalink":"http://yoursite.com/tags/requireJs/"}]},{"title":"我的第五篇博客","slug":"我的博客","date":"2017-08-17T12:22:30.000Z","updated":"2017-08-17T06:25:36.066Z","comments":true,"path":"2017/08/17/我的博客/","link":"","permalink":"http://yoursite.com/2017/08/17/我的博客/","excerpt":"","text":"git分支操作分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 为什么要有分支？ 如果你要开发一个新的功能，需要2周时间，第一周你只能写50%代码，如果此时立即提交，代码没写完，不完整的代码会影响到别人无法工作。如果等代码写完再提交，代码很容易丢失，风险很大。 有了分支，你就可以创建一个属于自己的分支，别人看不到，也不影响别人，你在自己的分支上工作，提交到自己的分支上，等到功能开发完毕，一次性的合并到原来的分支。这样既安全，又不影响他人工作。 在工作过程中，经常会碰到多任务并行开发 的情况，使用分支就能很好的避免任务之间的影响。 其他版本工具比如svn，cvs中也有分支这个概念，但是这些工具中的分支操作非常的慢，形同摆设。 分支操作的命令创建分支 git branch 分支名称创建分支，分支中的代码，在创建时与主分支的内容完全相同。 git在第一次提交时，就有了一个叫master的主分支。 查看分支 git branch可以查看所有的分支， 在当前分支的前面会有一个 切换分支 git checkout 分支名称切换分支 在当前分支的任何操作，都不会影响到其他的分支，除非进行了分支合并。 切换分支之前，必须保证代码已经提交了 创建并切换分支删除分支 git branch -d 分支名称 可以删除分支 注意：不能在当前分支删除当前分支，需要切换到其他分支才能删除。 注意：master分支是可以删除的，但是不推荐那么做。 合并分支 git merge 分支名称 将其他分支的内容合并到当前分支。 在master分支中执行git merge dev 将dev分支中的代码合并到master分支 git分支的工作原理git合并冲突 对于同一个文件，如果有多个分支需要合并时，容易出现冲突。 合并分支时，如果出现冲突，只能手动处理，再次提交，一般的作法，把自己的代码放到冲突代码的后面即可。 远程仓库所有的程序员都可以通过远程仓库来进行版本的共享，达到所有人的代码一致的效果。 创建远程仓库（了解） 创建远程仓库 git init --bare # 创建一个裸仓库 远程仓库是一个裸仓库，只支持push、clone、pull等操作 裸仓库的目的是用来管理版本的共享。 裸仓库不支持add commit等操作。不进行任何的开发工作。 一般裸仓库的名称会以.git结尾 远程仓库相关的命令git push 作用：将本地代码提交到远程仓库 git push 仓库地址 master 在代码提交到远程仓库，注意master分支必须写，不能省略 例子：git push git@github.com:hucongcong/test.git master 如果第一次使用，需要填写github的用户名和密码 git pull 作用：将远程的代码下载到本地 git pull 代码地址 master 将远程的代码中master分支下载到本地 通常在push前，需要先pull一次。 git clone 作用：克隆远程仓库的代码到本地 git clone 仓库地址 自定义本地仓库名 将整个仓库克隆到本地 git remote每次push和pull操作都需要带上远程仓库的地址，非常的麻烦，我们可以给仓库地址设置一个别名 git remote add 仓库别名 仓库地址 使用仓库别名替代仓库地址。仓库别名相当于一个js变量，仓库地址就是对应的值。 git remote add hucc git@github.com:hucongcong/test.git 设置了一个hucc的仓库别名，以后push和pull都可以不用仓库地址，而用hucc git remote remove hucc 删除hucc这个仓库别名。 git remote 查看所有的仓库别名 如果使用了git clone命令从远程仓库获取下来的，那么这个本地仓库会自动添加一个 origin的远程地址，指向的就是克隆的远程地址。 githubgit与github没有直接的关系。 git是一个版本控制工具。 github是一个代码托管平台，是git的一个远程代码仓库。 将来工作时，公司会有自己的代码仓库。 github官网 开源中国-git 1. gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。2. github免费，代码所有人都能看到，但是只有你自己能修改。付费的可以隐藏。 在github上创建一个项目，获取到仓库的地址。然后就可以将本地的代码推送到远程的服务器上。 SSH免登陆每次push代码，都需要输入用户名跟密码，非常的麻烦。因此我们可以配置一个SSH免登陆。 github为了账户的安全，需要对每一次push请求都要验证用户的身份，只有合法的用户才可以push 使用ssh可以实现免密码操作（不需要使用密码） 对称加密与非对称加密（了解）对称加密：采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。 优点：算法公开、计算量小、加密速度快、加密效率高 非对称加密：非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥） 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。 优点：更安全，缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 ssh免登录的原理SSH免登录配置 1 创建SSH Key：ssh-keygen -t rsa 2 在文件路径 C:\\用户\\当前用户名\\ 找到 .ssh 文件夹 3 文件夹中有两个文件： 私钥：id_rsa 公钥：id_rsa.pub 4 在 github -&gt; settings -&gt; SSH and GPG keys页面中，新创建SSH key 5 粘贴 公钥 id_rsa.pub 内容到对应文本框中 5 在github中新建仓库或者使用现在仓库，拿到git@github.com:用户名/仓库名.git 6 此后，再次SSH方式与github“通信”，不用输入密码确认身份了 使用github pages搭建博客GitHub Pages 本用于介绍托管在 GitHub 的项目， 不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。 缺点：只能放静态页面，也就说github pages只能解析html、css、js，无法解析后端语言。 博客搭建步骤： 在本地工作目录使用git初始化 git init 创建自己的博客项目 将创建好的博客添加到暂存区 git add [文件路径] 本地提交： git commit -m &quot;第一个博客&quot; 在github上创建一个项目，项目名用户名.github.io 固定的 提交到github：git push github仓库地址 master 查看github中对应的仓库中，是不是提交到了 访问：用户名.github.io hexo创建博客（了解）安装步骤 安装hexo npm install -g hexohexo -v # 查看hexo的版本信息 初始化博客 # 新建一个目录 bloghexo init # 初始化 生成静态页面 hexo generate # 生成静态页面 hexo g # 生成静态页面（简写） 启动服务 hexo server # 启动服务 访问站点 http://localhost:4000/ # 通过这个地址就可以访问了 hexo常见命令 hexo n &#39;博客标题&#39;创建一篇新的博客 hexo g 生成博客 hexo d 发布博客 hexo中文文档","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"git命令","slug":"git命令","permalink":"http://yoursite.com/tags/git命令/"}]},{"title":"我的第五篇博客","slug":"笔记","date":"2017-08-17T12:22:30.000Z","updated":"2017-08-17T05:11:42.019Z","comments":true,"path":"2017/08/17/笔记/","link":"","permalink":"http://yoursite.com/2017/08/17/笔记/","excerpt":"","text":"git分支操作分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 为什么要有分支？ 如果你要开发一个新的功能，需要2周时间，第一周你只能写50%代码，如果此时立即提交，代码没写完，不完整的代码会影响到别人无法工作。如果等代码写完再提交，代码很容易丢失，风险很大。 有了分支，你就可以创建一个属于自己的分支，别人看不到，也不影响别人，你在自己的分支上工作，提交到自己的分支上，等到功能开发完毕，一次性的合并到原来的分支。这样既安全，又不影响他人工作。 在工作过程中，经常会碰到多任务并行开发 的情况，使用分支就能很好的避免任务之间的影响。 其他版本工具比如svn，cvs中也有分支这个概念，但是这些工具中的分支操作非常的慢，形同摆设。 分支操作的命令创建分支 git branch 分支名称创建分支，分支中的代码，在创建时与主分支的内容完全相同。 git在第一次提交时，就有了一个叫master的主分支。 查看分支 git branch可以查看所有的分支， 在当前分支的前面会有一个 切换分支 git checkout 分支名称切换分支 在当前分支的任何操作，都不会影响到其他的分支，除非进行了分支合并。 切换分支之前，必须保证代码已经提交了 创建并切换分支删除分支 git branch -d 分支名称 可以删除分支 注意：不能在当前分支删除当前分支，需要切换到其他分支才能删除。 注意：master分支是可以删除的，但是不推荐那么做。 合并分支 git merge 分支名称 将其他分支的内容合并到当前分支。 在master分支中执行git merge dev 将dev分支中的代码合并到master分支 git分支的工作原理git合并冲突 对于同一个文件，如果有多个分支需要合并时，容易出现冲突。 合并分支时，如果出现冲突，只能手动处理，再次提交，一般的作法，把自己的代码放到冲突代码的后面即可。 远程仓库所有的程序员都可以通过远程仓库来进行版本的共享，达到所有人的代码一致的效果。 创建远程仓库（了解） 创建远程仓库 git init --bare # 创建一个裸仓库 远程仓库是一个裸仓库，只支持push、clone、pull等操作 裸仓库的目的是用来管理版本的共享。 裸仓库不支持add commit等操作。不进行任何的开发工作。 一般裸仓库的名称会以.git结尾 远程仓库相关的命令git push 作用：将本地代码提交到远程仓库 git push 仓库地址 master 在代码提交到远程仓库，注意master分支必须写，不能省略 例子：git push git@github.com:hucongcong/test.git master 如果第一次使用，需要填写github的用户名和密码 git pull 作用：将远程的代码下载到本地 git pull 代码地址 master 将远程的代码中master分支下载到本地 通常在push前，需要先pull一次。 git clone 作用：克隆远程仓库的代码到本地 git clone 仓库地址 自定义本地仓库名 将整个仓库克隆到本地 git remote每次push和pull操作都需要带上远程仓库的地址，非常的麻烦，我们可以给仓库地址设置一个别名 git remote add 仓库别名 仓库地址 使用仓库别名替代仓库地址。仓库别名相当于一个js变量，仓库地址就是对应的值。 git remote add hucc git@github.com:hucongcong/test.git 设置了一个hucc的仓库别名，以后push和pull都可以不用仓库地址，而用hucc git remote remove hucc 删除hucc这个仓库别名。 git remote 查看所有的仓库别名 如果使用了git clone命令从远程仓库获取下来的，那么这个本地仓库会自动添加一个 origin的远程地址，指向的就是克隆的远程地址。 githubgit与github没有直接的关系。 git是一个版本控制工具。 github是一个代码托管平台，是git的一个远程代码仓库。 将来工作时，公司会有自己的代码仓库。 github官网 开源中国-git 1. gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。2. github免费，代码所有人都能看到，但是只有你自己能修改。付费的可以隐藏。 在github上创建一个项目，获取到仓库的地址。然后就可以将本地的代码推送到远程的服务器上。 SSH免登陆每次push代码，都需要输入用户名跟密码，非常的麻烦。因此我们可以配置一个SSH免登陆。 github为了账户的安全，需要对每一次push请求都要验证用户的身份，只有合法的用户才可以push 使用ssh可以实现免密码操作（不需要使用密码） 对称加密与非对称加密（了解）对称加密：采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。 优点：算法公开、计算量小、加密速度快、加密效率高 非对称加密：非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥） 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。 优点：更安全，缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 ssh免登录的原理 SSH免登录配置 1 创建SSH Key：ssh-keygen -t rsa 2 在文件路径 C:\\用户\\当前用户名\\ 找到 .ssh 文件夹 3 文件夹中有两个文件： 私钥：id_rsa 公钥：id_rsa.pub 4 在 github -&gt; settings -&gt; SSH and GPG keys页面中，新创建SSH key 5 粘贴 公钥 id_rsa.pub 内容到对应文本框中 5 在github中新建仓库或者使用现在仓库，拿到git@github.com:用户名/仓库名.git 6 此后，再次SSH方式与github“通信”，不用输入密码确认身份了 使用github pages搭建博客GitHub Pages 本用于介绍托管在 GitHub 的项目， 不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。 缺点：只能放静态页面，也就说github pages只能解析html、css、js，无法解析后端语言。 博客搭建步骤： 在本地工作目录使用git初始化 git init 创建自己的博客项目 将创建好的博客添加到暂存区 git add [文件路径] 本地提交： git commit -m &quot;第一个博客&quot; 在github上创建一个项目，项目名用户名.github.io 固定的 提交到github：git push github仓库地址 master 查看github中对应的仓库中，是不是提交到了 访问：用户名.github.io hexo创建博客（了解）安装步骤 安装hexo npm install -g hexohexo -v # 查看hexo的版本信息 初始化博客 # 新建一个目录 bloghexo init # 初始化 生成静态页面 hexo generate # 生成静态页面 hexo g # 生成静态页面（简写） 启动服务 hexo server # 启动服务 访问站点 http://localhost:4000/ # 通过这个地址就可以访问了 hexo常见命令 hexo n &#39;博客标题&#39;创建一篇新的博客 hexo g 生成博客 hexo d 发布博客 hexo中文文档","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"git命令","slug":"git命令","permalink":"http://yoursite.com/tags/git命令/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-08-16T14:00:37.078Z","updated":"2017-08-16T12:18:55.000Z","comments":true,"path":"2017/08/16/hello-world/","link":"","permalink":"http://yoursite.com/2017/08/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2017-08-16T12:22:30.000Z","updated":"2017-08-16T13:10:35.332Z","comments":true,"path":"2017/08/16/我的第一篇博客/","link":"","permalink":"http://yoursite.com/2017/08/16/我的第一篇博客/","excerpt":"","text":"我是最大的标题我是二级标题我是三级标题 我是无序列表 我是无序列表 呵呵 嘻嘻 我是斜体代ma console.log(\"哈哈哈\");var num = 100;console.log(num);//这是注释|标题|描述| 这是加粗的文字","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"我的第一篇博客","slug":"我的第二篇博客 ","date":"2016-08-16T12:22:30.000Z","updated":"2017-08-16T13:34:55.940Z","comments":true,"path":"2016/08/16/我的第二篇博客 /","link":"","permalink":"http://yoursite.com/2016/08/16/我的第二篇博客 /","excerpt":"","text":"我是最大的标题我是二级标题我是三级标题 我是无序列表 我是无序列表 呵呵 嘻嘻 我是斜体代ma console.log(\"哈哈哈\");var num = 100;console.log(num);//这是注释|标题|描述| 这是加粗的文字","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"我的第四篇博客","slug":"我的第四篇博客","date":"2016-08-16T12:22:30.000Z","updated":"2017-08-16T14:49:24.992Z","comments":true,"path":"2016/08/16/我的第四篇博客/","link":"","permalink":"http://yoursite.com/2016/08/16/我的第四篇博客/","excerpt":"","text":"我是个好好孩子这是个真实的橘子请不要怀疑 我是无序列表 我是无序列表 呵呵 嘻嘻 我是斜体代ma console.log(\"哈哈哈\");var num = 100;console.log(num);//这是注释 这是加粗的文字","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]}